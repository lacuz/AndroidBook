## java虚拟机的特性
Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。

## 垃圾回收机制 
    主要分为两个步骤：
    1、检测垃圾
    2、回收垃圾

检测垃圾又有两种：

    - 引用计数法（已过时）
    给对象一个添加一个引用计数器，每当有一个地方引用该对象时，计数器加1，反之当引用无效时，计数器减1 。在任何时候，当计数器为0时，即没有任何地方引用该对象，表示该对象无用，即为回收器回收的对象。（因为这个方法无法解决对象之间相互循环引用的问题，所以被淘汰。）
    - 可达性分析
    通过GC root根节点往外遍历（可以想象树形图），当一个与root根节点可达的节点A所代表的对象持有另外一个节点B所代表的对象的引用，则视节点B为可达的。反之，如果某个节点是不可达的，则为可回收的对象。

回收垃圾

    标记 - 清除法（mark - sweep）
    标记所有需要回收的对象，然后统一清除。该方法简单粗暴，但是清除完会导致内存空间中出现大量碎片。

    复制（copying）
    把内存中的空间平分为两个，然后每次只使用任意一个。当回收垃圾时，遍历当前该内存区域，将正在使用的对象复制到另外一个内存区域中（复制过来后会自动整理，不会出现碎片的问题），然后再清空原来的内存区域。该方法通过两个内存区域的方法解决了碎片的问题，同时又迎来了新的问题，即提高了内存的空间要求，舍弃了空间换取了效率。

    标记 - 整理（mark - compact）
    第一阶段：从根节点标记所有能被引用的对象，即标记有用的对象。
    第二阶段：遍历整个堆中的对象，清除没有被标记的对象，并把剩下的 “压缩” 到堆中的其中一块，按顺序排放。
    该方法避免了 “ 标记 - 清除 ” 所造成的碎片问题，也解决了 “ 复制 ” 对空间的要求高的问题。

    分代收集算法
    根据每个对象生命周期不同的特点，将对象划分到不同代上，使用不同的垃圾回收方式。
    新生代：新创建的对象都是使用新生代分配内存。新生代里面又有三个区域（1个Eden区和2个Survivor区），新建的对象会放再Eden区，当Eden区满了就会执行 Minor GC ，然后把存活的对象转移到任意一个Survivor区。
    老年代：经过多次 Minor GC后依然存活的对象便送到该代，当该代内存被占满时就会触发Full GC回收整个内存。
    持久代：顾名思义。永生不死，相当于吸血鬼。用于存放java类等
